/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fast-average-color/dist/index.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-average-color/dist/index.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FastAverageColor\": () => (/* binding */ FastAverageColor)\n/* harmony export */ });\n/*! Fast Average Color | Â© 2022 Denis Seleznev | MIT License | https://github.com/fast-average-color/fast-average-color */\nfunction toHex(num) {\n    var str = num.toString(16);\n    return str.length === 1 ? '0' + str : str;\n}\nfunction arrayToHex(arr) {\n    return '#' + arr.map(toHex).join('');\n}\nfunction isDark(color) {\n    // http://www.w3.org/TR/AERT#color-contrast\n    var result = (color[0] * 299 + color[1] * 587 + color[2] * 114) / 1000;\n    return result < 128;\n}\nfunction prepareIgnoredColor(color) {\n    if (!color) {\n        return [];\n    }\n    return isRGBArray(color) ? color : [color];\n}\nfunction isRGBArray(value) {\n    return Array.isArray(value[0]);\n}\nfunction isIgnoredColor(data, index, ignoredColor) {\n    for (var i = 0; i < ignoredColor.length; i++) {\n        if (isIgnoredColorAsNumbers(data, index, ignoredColor[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isIgnoredColorAsNumbers(data, index, ignoredColor) {\n    switch (ignoredColor.length) {\n        case 3:\n            // [red, green, blue]\n            if (isIgnoredRGBColor(data, index, ignoredColor)) {\n                return true;\n            }\n            break;\n        case 4:\n            // [red, green, blue, alpha]\n            if (isIgnoredRGBAColor(data, index, ignoredColor)) {\n                return true;\n            }\n            break;\n        case 5:\n            // [red, green, blue, alpha, threshold]\n            if (isIgnoredRGBAColorWithThreshold(data, index, ignoredColor)) {\n                return true;\n            }\n            break;\n        default:\n            return false;\n    }\n}\nfunction isIgnoredRGBColor(data, index, ignoredColor) {\n    // Ignore if the pixel are transparent.\n    if (data[index + 3] !== 255) {\n        return true;\n    }\n    if (data[index] === ignoredColor[0] &&\n        data[index + 1] === ignoredColor[1] &&\n        data[index + 2] === ignoredColor[2]) {\n        return true;\n    }\n    return false;\n}\nfunction isIgnoredRGBAColor(data, index, ignoredColor) {\n    if (data[index + 3] && ignoredColor[3]) {\n        return data[index] === ignoredColor[0] &&\n            data[index + 1] === ignoredColor[1] &&\n            data[index + 2] === ignoredColor[2] &&\n            data[index + 3] === ignoredColor[3];\n    }\n    // Ignore rgb components if the pixel are fully transparent.\n    return data[index + 3] === ignoredColor[3];\n}\nfunction inRange(colorComponent, ignoredColorComponent, value) {\n    return colorComponent >= (ignoredColorComponent - value) &&\n        colorComponent <= (ignoredColorComponent + value);\n}\nfunction isIgnoredRGBAColorWithThreshold(data, index, ignoredColor) {\n    var redIgnored = ignoredColor[0];\n    var greenIgnored = ignoredColor[1];\n    var blueIgnored = ignoredColor[2];\n    var alphaIgnored = ignoredColor[3];\n    var threshold = ignoredColor[4];\n    var alphaData = data[index + 3];\n    var alphaInRange = inRange(alphaData, alphaIgnored, threshold);\n    if (!alphaIgnored) {\n        return alphaInRange;\n    }\n    if (!alphaData && alphaInRange) {\n        return true;\n    }\n    if (inRange(data[index], redIgnored, threshold) &&\n        inRange(data[index + 1], greenIgnored, threshold) &&\n        inRange(data[index + 2], blueIgnored, threshold) &&\n        alphaInRange) {\n        return true;\n    }\n    return false;\n}\n\nfunction dominantAlgorithm(arr, len, options) {\n    var colorHash = {};\n    var divider = 24;\n    var ignoredColor = options.ignoredColor;\n    var step = options.step;\n    var max = [0, 0, 0, 0, 0];\n    for (var i = 0; i < len; i += step) {\n        var red = arr[i];\n        var green = arr[i + 1];\n        var blue = arr[i + 2];\n        var alpha = arr[i + 3];\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n        var key = Math.round(red / divider) + ',' +\n            Math.round(green / divider) + ',' +\n            Math.round(blue / divider);\n        if (colorHash[key]) {\n            colorHash[key] = [\n                colorHash[key][0] + red * alpha,\n                colorHash[key][1] + green * alpha,\n                colorHash[key][2] + blue * alpha,\n                colorHash[key][3] + alpha,\n                colorHash[key][4] + 1\n            ];\n        }\n        else {\n            colorHash[key] = [red * alpha, green * alpha, blue * alpha, alpha, 1];\n        }\n        if (max[4] < colorHash[key][4]) {\n            max = colorHash[key];\n        }\n    }\n    var redTotal = max[0];\n    var greenTotal = max[1];\n    var blueTotal = max[2];\n    var alphaTotal = max[3];\n    var count = max[4];\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction simpleAlgorithm(arr, len, options) {\n    var redTotal = 0;\n    var greenTotal = 0;\n    var blueTotal = 0;\n    var alphaTotal = 0;\n    var count = 0;\n    var ignoredColor = options.ignoredColor;\n    var step = options.step;\n    for (var i = 0; i < len; i += step) {\n        var alpha = arr[i + 3];\n        var red = arr[i] * alpha;\n        var green = arr[i + 1] * alpha;\n        var blue = arr[i + 2] * alpha;\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n        redTotal += red;\n        greenTotal += green;\n        blueTotal += blue;\n        alphaTotal += alpha;\n        count++;\n    }\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction sqrtAlgorithm(arr, len, options) {\n    var redTotal = 0;\n    var greenTotal = 0;\n    var blueTotal = 0;\n    var alphaTotal = 0;\n    var count = 0;\n    var ignoredColor = options.ignoredColor;\n    var step = options.step;\n    for (var i = 0; i < len; i += step) {\n        var red = arr[i];\n        var green = arr[i + 1];\n        var blue = arr[i + 2];\n        var alpha = arr[i + 3];\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n        redTotal += red * red * alpha;\n        greenTotal += green * green * alpha;\n        blueTotal += blue * blue * alpha;\n        alphaTotal += alpha;\n        count++;\n    }\n    return alphaTotal ? [\n        Math.round(Math.sqrt(redTotal / alphaTotal)),\n        Math.round(Math.sqrt(greenTotal / alphaTotal)),\n        Math.round(Math.sqrt(blueTotal / alphaTotal)),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction getDefaultColor(options) {\n    return getOption(options, 'defaultColor', [0, 0, 0, 0]);\n}\nfunction getOption(options, name, defaultValue) {\n    return (options[name] === undefined ? defaultValue : options[name]);\n}\n\nvar MIN_SIZE = 10;\nvar MAX_SIZE = 100;\nfunction isSvg(filename) {\n    return filename.search(/\\.svg(\\?|$)/i) !== -1;\n}\nfunction getOriginalSize(resource) {\n    if (isInstanceOfHTMLImageElement(resource)) {\n        var width = resource.naturalWidth;\n        var height = resource.naturalHeight;\n        // For SVG images with only viewBox attribute\n        if (!resource.naturalWidth && isSvg(resource.src)) {\n            width = height = MAX_SIZE;\n        }\n        return {\n            width: width,\n            height: height,\n        };\n    }\n    if (isInstanceOfHTMLVideoElement(resource)) {\n        return {\n            width: resource.videoWidth,\n            height: resource.videoHeight\n        };\n    }\n    return {\n        width: resource.width,\n        height: resource.height\n    };\n}\nfunction getSrc(resource) {\n    if (isInstanceOfHTMLCanvasElement(resource)) {\n        return 'canvas';\n    }\n    if (isInstanceOfOffscreenCanvas(resource)) {\n        return 'offscreencanvas';\n    }\n    if (isInstanceOfImageBitmap(resource)) {\n        return 'imagebitmap';\n    }\n    return resource.src;\n}\nfunction isInstanceOfHTMLImageElement(resource) {\n    return typeof HTMLImageElement !== 'undefined' && resource instanceof HTMLImageElement;\n}\nvar hasOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\nfunction isInstanceOfOffscreenCanvas(resource) {\n    return hasOffscreenCanvas && resource instanceof OffscreenCanvas;\n}\nfunction isInstanceOfHTMLVideoElement(resource) {\n    return typeof HTMLVideoElement !== 'undefined' && resource instanceof HTMLVideoElement;\n}\nfunction isInstanceOfHTMLCanvasElement(resource) {\n    return typeof HTMLCanvasElement !== 'undefined' && resource instanceof HTMLCanvasElement;\n}\nfunction isInstanceOfImageBitmap(resource) {\n    return typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap;\n}\nfunction prepareSizeAndPosition(originalSize, options) {\n    var srcLeft = getOption(options, 'left', 0);\n    var srcTop = getOption(options, 'top', 0);\n    var srcWidth = getOption(options, 'width', originalSize.width);\n    var srcHeight = getOption(options, 'height', originalSize.height);\n    var destWidth = srcWidth;\n    var destHeight = srcHeight;\n    if (options.mode === 'precision') {\n        return {\n            srcLeft: srcLeft,\n            srcTop: srcTop,\n            srcWidth: srcWidth,\n            srcHeight: srcHeight,\n            destWidth: destWidth,\n            destHeight: destHeight\n        };\n    }\n    var factor;\n    if (srcWidth > srcHeight) {\n        factor = srcWidth / srcHeight;\n        destWidth = MAX_SIZE;\n        destHeight = Math.round(destWidth / factor);\n    }\n    else {\n        factor = srcHeight / srcWidth;\n        destHeight = MAX_SIZE;\n        destWidth = Math.round(destHeight / factor);\n    }\n    if (destWidth > srcWidth || destHeight > srcHeight ||\n        destWidth < MIN_SIZE || destHeight < MIN_SIZE) {\n        destWidth = srcWidth;\n        destHeight = srcHeight;\n    }\n    return {\n        srcLeft: srcLeft,\n        srcTop: srcTop,\n        srcWidth: srcWidth,\n        srcHeight: srcHeight,\n        destWidth: destWidth,\n        destHeight: destHeight\n    };\n}\nvar isWebWorkers = typeof window === 'undefined';\nfunction makeCanvas() {\n    if (isWebWorkers) {\n        return hasOffscreenCanvas ? new OffscreenCanvas(1, 1) : null;\n    }\n    return document.createElement('canvas');\n}\n\nvar ERROR_PREFIX = 'FastAverageColor: ';\nfunction getError(message) {\n    return Error(ERROR_PREFIX + message);\n}\nfunction outputError(error, silent) {\n    if (!silent) {\n        console.error(error);\n    }\n}\n\nvar FastAverageColor = /** @class */ (function () {\n    function FastAverageColor() {\n        this.canvas = null;\n        this.ctx = null;\n    }\n    /**\n     * Get asynchronously the average color from not loaded image.\n     */\n    FastAverageColor.prototype.getColorAsync = function (resource, options) {\n        if (!resource) {\n            return Promise.reject(getError('call .getColorAsync() without resource.'));\n        }\n        if (typeof resource === 'string') {\n            // Web workers\n            if (typeof Image === 'undefined') {\n                return Promise.reject(getError('resource as string is not supported in this environment'));\n            }\n            var img = new Image();\n            img.crossOrigin = options && options.crossOrigin || '';\n            img.src = resource;\n            return this.bindImageEvents(img, options);\n        }\n        else if (isInstanceOfHTMLImageElement(resource) && !resource.complete) {\n            return this.bindImageEvents(resource, options);\n        }\n        else {\n            var result = this.getColor(resource, options);\n            return result.error ? Promise.reject(result.error) : Promise.resolve(result);\n        }\n    };\n    /**\n     * Get the average color from images, videos and canvas.\n     */\n    FastAverageColor.prototype.getColor = function (resource, options) {\n        options = options || {};\n        var defaultColor = getDefaultColor(options);\n        if (!resource) {\n            var error = getError('call .getColor(null) without resource');\n            outputError(error, options.silent);\n            return this.prepareResult(defaultColor, error);\n        }\n        var originalSize = getOriginalSize(resource);\n        var size = prepareSizeAndPosition(originalSize, options);\n        if (!size.srcWidth || !size.srcHeight || !size.destWidth || !size.destHeight) {\n            var error = getError(\"incorrect sizes for resource \\\"\".concat(getSrc(resource), \"\\\"\"));\n            outputError(error, options.silent);\n            return this.prepareResult(defaultColor, error);\n        }\n        if (!this.canvas) {\n            this.canvas = makeCanvas();\n            if (!this.canvas) {\n                var error = getError('OffscreenCanvas is not supported in this browser');\n                outputError(error, options.silent);\n                return this.prepareResult(defaultColor, error);\n            }\n        }\n        if (!this.ctx) {\n            this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n            if (!this.ctx) {\n                var error = getError('Canvas Context 2D is not supported in this browser');\n                outputError(error, options.silent);\n                return this.prepareResult(defaultColor);\n            }\n            this.ctx.imageSmoothingEnabled = false;\n        }\n        this.canvas.width = size.destWidth;\n        this.canvas.height = size.destHeight;\n        try {\n            this.ctx.clearRect(0, 0, size.destWidth, size.destHeight);\n            this.ctx.drawImage(resource, size.srcLeft, size.srcTop, size.srcWidth, size.srcHeight, 0, 0, size.destWidth, size.destHeight);\n            var bitmapData = this.ctx.getImageData(0, 0, size.destWidth, size.destHeight).data;\n            return this.prepareResult(this.getColorFromArray4(bitmapData, options));\n        }\n        catch (originalError) {\n            var error = getError(\"security error (CORS) for resource \".concat(getSrc(resource), \".\\nDetails: https://developer.mozilla.org/en/docs/Web/HTML/CORS_enabled_image\"));\n            outputError(error, options.silent);\n            !options.silent && console.error(originalError);\n            return this.prepareResult(defaultColor, error);\n        }\n    };\n    /**\n     * Get the average color from a array when 1 pixel is 4 bytes.\n     */\n    FastAverageColor.prototype.getColorFromArray4 = function (arr, options) {\n        options = options || {};\n        var bytesPerPixel = 4;\n        var arrLength = arr.length;\n        var defaultColor = getDefaultColor(options);\n        if (arrLength < bytesPerPixel) {\n            return defaultColor;\n        }\n        var len = arrLength - arrLength % bytesPerPixel;\n        var step = (options.step || 1) * bytesPerPixel;\n        var algorithm;\n        switch (options.algorithm || 'sqrt') {\n            case 'simple':\n                algorithm = simpleAlgorithm;\n                break;\n            case 'sqrt':\n                algorithm = sqrtAlgorithm;\n                break;\n            case 'dominant':\n                algorithm = dominantAlgorithm;\n                break;\n            default:\n                throw getError(\"\".concat(options.algorithm, \" is unknown algorithm\"));\n        }\n        return algorithm(arr, len, {\n            defaultColor: defaultColor,\n            ignoredColor: prepareIgnoredColor(options.ignoredColor),\n            step: step\n        });\n    };\n    /**\n     * Get color data from value ([r, g, b, a]).\n     */\n    FastAverageColor.prototype.prepareResult = function (value, error) {\n        var rgb = value.slice(0, 3);\n        var rgba = [value[0], value[1], value[2], value[3] / 255];\n        var isDarkColor = isDark(value);\n        return {\n            value: [value[0], value[1], value[2], value[3]],\n            rgb: 'rgb(' + rgb.join(',') + ')',\n            rgba: 'rgba(' + rgba.join(',') + ')',\n            hex: arrayToHex(rgb),\n            hexa: arrayToHex(value),\n            isDark: isDarkColor,\n            isLight: !isDarkColor,\n            error: error,\n        };\n    };\n    /**\n     * Destroy the instance.\n     */\n    FastAverageColor.prototype.destroy = function () {\n        if (this.canvas) {\n            this.canvas.width = 1;\n            this.canvas.height = 1;\n            this.canvas = null;\n        }\n        this.ctx = null;\n    };\n    FastAverageColor.prototype.bindImageEvents = function (resource, options) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var onload = function () {\n                unbindEvents();\n                var result = _this.getColor(resource, options);\n                if (result.error) {\n                    reject(result.error);\n                }\n                else {\n                    resolve(result);\n                }\n            };\n            var onerror = function () {\n                unbindEvents();\n                reject(getError(\"Error loading image \\\"\".concat(resource.src, \"\\\".\")));\n            };\n            var onabort = function () {\n                unbindEvents();\n                reject(getError(\"Image \\\"\".concat(resource.src, \"\\\" loading aborted\")));\n            };\n            var unbindEvents = function () {\n                resource.removeEventListener('load', onload);\n                resource.removeEventListener('error', onerror);\n                resource.removeEventListener('abort', onabort);\n            };\n            resource.addEventListener('load', onload);\n            resource.addEventListener('error', onerror);\n            resource.addEventListener('abort', onabort);\n        });\n    };\n    return FastAverageColor;\n}());\n\n\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/fast-average-color/dist/index.esm.js?");

/***/ }),

/***/ "./src/CanvasStream.js":
/*!*****************************!*\
  !*** ./src/CanvasStream.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasStream\": () => (/* binding */ CanvasStream)\n/* harmony export */ });\nclass CanvasStream extends WritableStream {\n  constructor(canvas, draw) {\n    super({\n      write: (chunk) => draw(this.ctx, chunk),\n    });\n    this.ctx = canvas.getContext(\"2d\");\n  }\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./src/CanvasStream.js?");

/***/ }),

/***/ "./src/HomeAssistant.js":
/*!******************************!*\
  !*** ./src/HomeAssistant.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HomeAssistant\": () => (/* binding */ HomeAssistant),\n/* harmony export */   \"HomeAssistantConnectedEvent\": () => (/* binding */ HomeAssistantConnectedEvent),\n/* harmony export */   \"HomeAssistantDisconnectedEvent\": () => (/* binding */ HomeAssistantDisconnectedEvent)\n/* harmony export */ });\n/* harmony import */ var home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! home-assistant-js-websocket */ \"./node_modules/home-assistant-js-websocket/dist/auth.js\");\n/* harmony import */ var home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! home-assistant-js-websocket */ \"./node_modules/home-assistant-js-websocket/dist/index.js\");\n/* harmony import */ var home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! home-assistant-js-websocket */ \"./node_modules/home-assistant-js-websocket/dist/entities.js\");\n/* harmony import */ var home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! home-assistant-js-websocket */ \"./node_modules/home-assistant-js-websocket/dist/errors.js\");\n/* harmony import */ var home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! home-assistant-js-websocket */ \"./node_modules/home-assistant-js-websocket/dist/commands.js\");\n\n\nclass HomeAssistantConnectedEvent extends Event {\n  static type = \"HomeAssistantConnectedEvent\";\n  constructor(connection) {\n    super(HomeAssistantConnectedEvent.type);\n    this.connection = connection;\n  }\n}\n\nclass HomeAssistantDisconnectedEvent extends Event {\n  static type = \"HomeAssistantDisconnectedEvent\";\n  constructor(connection) {\n    super(HomeAssistantDisconnectedEvent.type);\n    this.connection = connection;\n  }\n}\n\nclass HomeAssistant extends EventTarget {\n  constructor() {\n    super()\n    this.authOptions = {\n      async loadTokens() {\n        try {\n          return JSON.parse(localStorage.hassTokens);\n        } catch (err) {\n          return undefined;\n        }\n      },\n      saveTokens: (tokens) => {\n        localStorage.hassTokens = JSON.stringify(tokens);\n      },\n    };\n\n    this.lights = [];\n\n    setInterval(async () => await this.tick(), 100);\n  }\n\n  async load() {\n    try {\n      this.auth = await (0,home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_0__.getAuth)(this.authOptions);\n      // Clear url if we have been able to establish a connection\n      if (location.search.includes(\"auth_callback=1\")) {\n        history.replaceState(null, \"\", location.pathname);\n      }\n\n      this.connection = await (0,home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_1__.createConnection)({ auth: this.auth });\n\n      (0,home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_2__.subscribeEntities)(this.connection, (entities) => {\n        this.lights = Object.keys(entities).filter(entityId => entityId.startsWith(\"light.\"));\n        console.log(this.lights);\n      });\n\n      this.dispatchEvent(new HomeAssistantConnectedEvent(this.connection));\n\n      // To play from the console\n      window.auth = this.auth;\n      window.connection = this.connection;\n    } catch (err) {\n      if (err !== home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_3__.ERR_HASS_HOST_REQUIRED) {\n        console.error(err);\n      }\n    }\n  }\n\n  async authenticate() {\n    try {\n      this.auth = await (0,home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_0__.getAuth)(this.authOptions);\n    } catch (err) {\n      if (err === home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_3__.ERR_HASS_HOST_REQUIRED) {\n        this.authOptions.hassUrl = prompt(\"What host to connect to?\", \"http://192.168.0.10:8123\");\n        if (!authOptions.hassUrl) return;\n        this.auth = await (0,home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_0__.getAuth)(this.authOptions);\n      } else {\n        alert(`Unknown error: ${err}`);\n        return;\n      }\n    }\n    await this.load();\n  }\n\n  async disconnect() {\n    if (this.connection) {\n      if (this.entityId) {\n        await (0,home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_4__.callService)(\n          this.connection,\n          \"light\",\n          \"turn_on\",\n          {\n            rgb_color: [255,202,123],\n            brightness: 100,\n            transition: false,\n          },\n          {\n            entity_id: this.entityId,\n          }\n        );\n      }\n\n      this.connection.close();\n      this.dispatchEvent(new HomeAssistantDisconnectedEvent(this.connection));\n      delete this.connection;\n      delete this.auth;\n    }\n  }\n\n  setEntity(entityId) {\n    this.entityId = entityId;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  async tick() {\n    if (\n      this.connection &&\n      this.color &&\n      (!this.lastColor || this.lastColor[0] !== this.color[0] || this.lastColor[1] !== this.color[1] || this.lastColor[2] !== this.color[2])\n    ) {\n      this.lastColor = this.color;\n      await (0,home_assistant_js_websocket__WEBPACK_IMPORTED_MODULE_4__.callService)(\n        this.connection,\n        \"light\",\n        \"turn_on\",\n        {\n          rgb_color: this.color,\n          brightness: this.color[0] + this.color[1] + this.color[2] == 0 ? \"0\" : \"255\",\n          transition: false,\n        },\n        {\n          entity_id: this.entityId,\n        }\n      );\n    }\n  }\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./src/HomeAssistant.js?");

/***/ }),

/***/ "./src/OverlayRectSelector.js":
/*!************************************!*\
  !*** ./src/OverlayRectSelector.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OverlayRectSelector\": () => (/* binding */ OverlayRectSelector)\n/* harmony export */ });\nconst ev = (c) => (e) => {\n  e.preventDefault();\n  e.stopPropagation();\n  c(e);\n};\n\nclass OverlayRectSelector {\n  constructor(overlay, rectSelected) {\n    this.overlay = overlay;\n    this.ctx = overlay.getContext(\"2d\");\n    this.rectSelected = rectSelected;\n    this.isDown = false;\n    this.startX = null;\n    this.startY = null;\n\n    overlay.onmousedown = this.onmousedown.bind(this);\n    overlay.onmousemove = this.onmousemove.bind(this);\n    overlay.onmouseout = this.onmouseup.bind(this);\n    overlay.onmouseup = this.onmouseup.bind(this);\n  }\n\n  drawRect = (e) => {\n    const { offsetX, offsetY } = this.rel(e);\n\n    this.ctx.clearRect(0, 0, this.overlay.width, this.overlay.height);\n\n    this.ctx.lineWidth = this.overlay.width / 300;\n    this.ctx.strokeStyle = \"red\";\n    this.ctx.strokeRect(...this.abs(this.startX, this.startY, offsetX - this.startX, offsetY - this.startY));\n  };\n\n  onmousedown = ev((e) => {\n    this.isDown = true;\n    const { offsetX, offsetY } = this.rel(e);\n\n    this.startX = offsetX;\n    this.startY = offsetY;\n  });\n\n  onmousemove = ev((e) => {\n    if (!this.isDown) return;\n    this.drawRect(e);\n  });\n\n  onmouseup = ev((e) => {\n    if (!this.isDown) return;\n    this.isDown = false;\n    \n    this.drawRect(e);\n\n    const { offsetX, offsetY } = this.rel(e);\n    this.rectSelected(...this.abs(this.startX, this.startY, offsetX - this.startX, offsetY - this.startY));\n  });\n\n  abs = (x,y,w,h) => [x * this.overlay.width, y * this.overlay.height, w * this.overlay.width, h * this.overlay.height];\n  rel = (e) => {\n    const { width, height } = this.overlay.getBoundingClientRect();\n    return {\n      offsetX: e.offsetX / width,\n      offsetY: e.offsetY / height,\n    };\n  };\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./src/OverlayRectSelector.js?");

/***/ }),

/***/ "./src/VideoCropper.js":
/*!*****************************!*\
  !*** ./src/VideoCropper.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VideoCropper\": () => (/* binding */ VideoCropper)\n/* harmony export */ });\nclass VideoCropper {\n    cropVideo = (source, destination, x, y, width, height) => {\n        if (this.worker) {\n            this.worker.terminate();\n        }\n        this.worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"CropWorker\"), __webpack_require__.b), { name: \"CropWorker\" });\n        const [track] = source.getTracks();\n        const processor = new MediaStreamTrackProcessor({ track });\n        const { readable } = processor;\n      \n        const generator = new MediaStreamTrackGenerator({ kind: \"video\" });\n        const { writable } = generator;\n      \n        const mediaStream = new MediaStream([generator]);\n      \n        const processor2 = new MediaStreamTrackProcessor({\n          track: mediaStream.getVideoTracks()[0],\n        });\n        const readable2 = processor2.readable;\n      \n        readable2.pipeTo(destination);\n      \n        this.worker.postMessage(\n          {\n            x,\n            y,\n            width,\n            height,\n            readable,\n            writable,\n          },\n          [readable, writable]\n        );\n      }\n}\n\n//# sourceURL=webpack://duckyc.github.io/./src/VideoCropper.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fast_average_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-average-color */ \"./node_modules/fast-average-color/dist/index.esm.js\");\n/* harmony import */ var _CanvasStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CanvasStream */ \"./src/CanvasStream.js\");\n/* harmony import */ var _HomeAssistant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HomeAssistant */ \"./src/HomeAssistant.js\");\n/* harmony import */ var _OverlayRectSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OverlayRectSelector */ \"./src/OverlayRectSelector.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _VideoCropper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VideoCropper */ \"./src/VideoCropper.js\");\n\nconst fac = new fast_average_color__WEBPACK_IMPORTED_MODULE_0__.FastAverageColor()\n\n;\n\n\n\n\n\nconst startElem = document.getElementById(\"start\");\n\nconst video = document.getElementById(\"video\");\nconst overlay = document.getElementById(\"overlay\");\n\nconst cropped = document.getElementById(\"cropped\");\nconst output = document.getElementById(\"color\");\n\nconst connect = document.getElementById(\"connect\");\nconst disconnect = document.getElementById(\"disconnect\");\nconst entitySelect = document.getElementById(\"entity-select\");\nconst light_entityid = document.getElementById(\"light_entityid\")\nentitySelect.style.display = \"none\";\ndisconnect.style.display = \"none\";\n\nconst homeAssistant = new _HomeAssistant__WEBPACK_IMPORTED_MODULE_2__.HomeAssistant();\nconst predefinedLight = localStorage.getItem(\"light_entityid\")\nif(predefinedLight) {\n  homeAssistant.setEntity(predefinedLight)\n  light_entityid.innerHTML = predefinedLight\n}\nhomeAssistant.addEventListener(_HomeAssistant__WEBPACK_IMPORTED_MODULE_2__.HomeAssistantConnectedEvent.type, (e) => {\n  connect.style.display = \"none\";\n  disconnect.style.display = \"block\";\n  entitySelect.style.display = \"block\";\n});\n\nhomeAssistant.addEventListener(_HomeAssistant__WEBPACK_IMPORTED_MODULE_2__.HomeAssistantDisconnectedEvent.type, (e) => {\n  connect.style.display = \"block\";\n  disconnect.style.display = \"none\";\n});\n\nhomeAssistant.load();\n\nconnect.onclick = async () => {\n  await homeAssistant.authenticate();\n};\ndisconnect.onclick = async () => {\n  await homeAssistant.disconnect();\n};\nentitySelect.onclick = async() => {\n  const entityId = prompt(\"Which light do you want to use?\\nMust be one of these:\\n\\n\"+homeAssistant.lights.join(\"\\n\"), localStorage.getItem(\"light_entityid\") ?? homeAssistant.lights[0]);\n  homeAssistant.setEntity(entityId)\n  localStorage.setItem(\"light_entityid\", entityId)\n  light_entityid.innerHTML = entityId\n}\n\nconst createCroppedCanvasStream = () => new _CanvasStream__WEBPACK_IMPORTED_MODULE_1__.CanvasStream(cropped, (ctx, videoFrame) => {\n  if (cropped.width !== videoFrame.displayWidth || cropped.height !== videoFrame.displayHeight) {\n    cropped.width = videoFrame.displayWidth;\n    cropped.height = videoFrame.displayHeight;\n  }\n\n  ctx.clearRect(0, 0, video.width, video.height);\n  ctx.drawImage(videoFrame, 0, 0);\n  videoFrame.close();\n\n  const color = fac.getColor(cropped, {\n    algorithm: \"dominant\",\n    ignoredColor: [\n      [0, 0, 0, 255, 50],\n      [255, 255, 255, 255, 50],\n    ],\n  });\n\n  var averageColor\n  const hsv = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.RGBtoHSV)(...color.value);\n  if (hsv.h == 0) {\n    averageColor = [0, 0, 0];\n  } else {\n    const trueColor = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.HSVtoRGB)(hsv.h, 1, 1);\n    averageColor = [trueColor.r, trueColor.g, trueColor.b];\n  }\n\n  output.style[\"background-color\"] = `rgb(${averageColor.join(\",\")})`;\n  homeAssistant.setColor(averageColor)\n});\n\nconst videoCropper = new _VideoCropper__WEBPACK_IMPORTED_MODULE_5__.VideoCropper();\nconst overlayRectSelector = new _OverlayRectSelector__WEBPACK_IMPORTED_MODULE_3__.OverlayRectSelector(overlay, (..._) => videoCropper.cropVideo(video.srcObject, createCroppedCanvasStream(), ..._));\n\nstartElem.onclick = async () => {\n  const capture = await navigator.mediaDevices.getDisplayMedia({\n    video: {\n      cursor: \"never\",\n    },\n    audio: false,\n  });\n\n  video.srcObject = capture;\n  const track = capture.getVideoTracks()[0];\n  const processor = new MediaStreamTrackProcessor(track);\n\n  const canvasStream = new _CanvasStream__WEBPACK_IMPORTED_MODULE_1__.CanvasStream(video, (ctx, videoFrame) => {\n    if (video.width !== videoFrame.displayWidth || video.height !== videoFrame.displayHeight) {\n      video.width = videoFrame.displayWidth;\n      video.height = videoFrame.displayHeight;\n\n      const { width, height, left, top } = video.getBoundingClientRect();\n      overlay.width = video.width;\n      overlay.height = video.height;\n      console.log(video.width, overlay.width);\n      // overlay.style.width = width + \"px\";\n      // overlay.style.height = height + \"px\";\n      overlay.style.left = left + \"px\";\n      overlay.style.top = top + \"px\";\n    }\n\n    ctx.clearRect(0, 0, video.width, video.height);\n    ctx.drawImage(videoFrame, 0, 0);\n    videoFrame.close();\n  });\n\n  processor.readable.pipeTo(canvasStream);\n\n  startElem.style.display = \"none\";\n};\n\n\n//# sourceURL=webpack://duckyc.github.io/./src/index.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HSVtoRGB\": () => (/* binding */ HSVtoRGB),\n/* harmony export */   \"RGBtoHSV\": () => (/* binding */ RGBtoHSV)\n/* harmony export */ });\nfunction RGBtoHSV(r, g, b) {\n  if (arguments.length === 1) {\n    (g = r.g), (b = r.b), (r = r.r);\n  }\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b),\n    d = max - min,\n    h,\n    s = max === 0 ? 0 : d / max,\n    v = max / 255;\n\n  switch (max) {\n    case min:\n      h = 0;\n      break;\n    case r:\n      h = g - b + d * (g < b ? 6 : 0);\n      h /= 6 * d;\n      break;\n    case g:\n      h = b - r + d * 2;\n      h /= 6 * d;\n      break;\n    case b:\n      h = r - g + d * 4;\n      h /= 6 * d;\n      break;\n  }\n\n  return {\n    h: h,\n    s: s,\n    v: v,\n  };\n}\n\nfunction HSVtoRGB(h, s, v) {\n  var r, g, b, i, f, p, q, t;\n  if (arguments.length === 1) {\n    (s = h.s), (v = h.v), (h = h.h);\n  }\n  i = Math.floor(h * 6);\n  f = h * 6 - i;\n  p = v * (1 - s);\n  q = v * (1 - f * s);\n  t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      (r = v), (g = t), (b = p);\n      break;\n    case 1:\n      (r = q), (g = v), (b = p);\n      break;\n    case 2:\n      (r = p), (g = v), (b = t);\n      break;\n    case 3:\n      (r = p), (g = q), (b = v);\n      break;\n    case 4:\n      (r = t), (g = p), (b = v);\n      break;\n    case 5:\n      (r = v), (g = p), (b = q);\n      break;\n  }\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255),\n  };\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./src/utils.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/auth.js":
/*!***************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/auth.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Auth\": () => (/* binding */ Auth),\n/* harmony export */   \"createLongLivedTokenAuth\": () => (/* binding */ createLongLivedTokenAuth),\n/* harmony export */   \"genClientId\": () => (/* binding */ genClientId),\n/* harmony export */   \"genExpires\": () => (/* binding */ genExpires),\n/* harmony export */   \"getAuth\": () => (/* binding */ getAuth)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/home-assistant-js-websocket/dist/util.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/home-assistant-js-websocket/dist/errors.js\");\n\n\nconst genClientId = () => `${location.protocol}//${location.host}/`;\nconst genExpires = (expires_in) => {\n    return expires_in * 1000 + Date.now();\n};\nfunction genRedirectUrl() {\n    // Get current url but without # part.\n    const { protocol, host, pathname, search } = location;\n    return `${protocol}//${host}${pathname}${search}`;\n}\nfunction genAuthorizeUrl(hassUrl, clientId, redirectUrl, state) {\n    let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n    if (clientId !== null) {\n        authorizeUrl += `&client_id=${encodeURIComponent(clientId)}`;\n    }\n    if (state) {\n        authorizeUrl += `&state=${encodeURIComponent(state)}`;\n    }\n    return authorizeUrl;\n}\nfunction redirectAuthorize(hassUrl, clientId, redirectUrl, state) {\n    // Add either ?auth_callback=1 or &auth_callback=1\n    redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n    document.location.href = genAuthorizeUrl(hassUrl, clientId, redirectUrl, state);\n}\nasync function tokenRequest(hassUrl, clientId, data) {\n    // Browsers don't allow fetching tokens from https -> http.\n    // Throw an error because it's a pain to debug this.\n    // Guard against not working in node.\n    const l = typeof location !== \"undefined\" && location;\n    if (l && l.protocol === \"https:\") {\n        // Ensure that the hassUrl is hosted on https.\n        const a = document.createElement(\"a\");\n        a.href = hassUrl;\n        if (a.protocol === \"http:\" && a.hostname !== \"localhost\") {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ERR_INVALID_HTTPS_TO_HTTP;\n        }\n    }\n    const formData = new FormData();\n    if (clientId !== null) {\n        formData.append(\"client_id\", clientId);\n    }\n    Object.keys(data).forEach((key) => {\n        formData.append(key, data[key]);\n    });\n    const resp = await fetch(`${hassUrl}/auth/token`, {\n        method: \"POST\",\n        credentials: \"same-origin\",\n        body: formData,\n    });\n    if (!resp.ok) {\n        throw resp.status === 400 /* auth invalid */ ||\n            resp.status === 403 /* user not active */\n            ? _errors_js__WEBPACK_IMPORTED_MODULE_0__.ERR_INVALID_AUTH\n            : new Error(\"Unable to fetch tokens\");\n    }\n    const tokens = await resp.json();\n    tokens.hassUrl = hassUrl;\n    tokens.clientId = clientId;\n    tokens.expires = genExpires(tokens.expires_in);\n    return tokens;\n}\nfunction fetchToken(hassUrl, clientId, code) {\n    return tokenRequest(hassUrl, clientId, {\n        code,\n        grant_type: \"authorization_code\",\n    });\n}\nfunction encodeOAuthState(state) {\n    return btoa(JSON.stringify(state));\n}\nfunction decodeOAuthState(encoded) {\n    return JSON.parse(atob(encoded));\n}\nclass Auth {\n    constructor(data, saveTokens) {\n        this.data = data;\n        this._saveTokens = saveTokens;\n    }\n    get wsUrl() {\n        // Convert from http:// -> ws://, https:// -> wss://\n        return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n    }\n    get accessToken() {\n        return this.data.access_token;\n    }\n    get expired() {\n        return Date.now() > this.data.expires;\n    }\n    /**\n     * Refresh the access token.\n     */\n    async refreshAccessToken() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token\");\n        const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n            grant_type: \"refresh_token\",\n            refresh_token: this.data.refresh_token,\n        });\n        // Access token response does not contain refresh token.\n        data.refresh_token = this.data.refresh_token;\n        this.data = data;\n        if (this._saveTokens)\n            this._saveTokens(data);\n    }\n    /**\n     * Revoke the refresh & access tokens.\n     */\n    async revoke() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token to revoke\");\n        const formData = new FormData();\n        formData.append(\"token\", this.data.refresh_token);\n        // There is no error checking, as revoke will always return 200\n        await fetch(`${this.data.hassUrl}/auth/revoke`, {\n            method: \"POST\",\n            credentials: \"same-origin\",\n            body: formData,\n        });\n        if (this._saveTokens) {\n            this._saveTokens(null);\n        }\n    }\n}\nfunction createLongLivedTokenAuth(hassUrl, access_token) {\n    return new Auth({\n        hassUrl,\n        clientId: null,\n        expires: Date.now() + 1e11,\n        refresh_token: \"\",\n        access_token,\n        expires_in: 1e11,\n    });\n}\nasync function getAuth(options = {}) {\n    let data;\n    let hassUrl = options.hassUrl;\n    // Strip trailing slash.\n    if (hassUrl && hassUrl[hassUrl.length - 1] === \"/\") {\n        hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n    }\n    const clientId = options.clientId !== undefined ? options.clientId : genClientId();\n    // Use auth code if it was passed in\n    if (!data && options.authCode && hassUrl) {\n        data = await fetchToken(hassUrl, clientId, options.authCode);\n        if (options.saveTokens) {\n            options.saveTokens(data);\n        }\n    }\n    // Check if we came back from an authorize redirect\n    if (!data) {\n        const query = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.parseQuery)(location.search.substr(1));\n        // Check if we got redirected here from authorize page\n        if (\"auth_callback\" in query) {\n            // Restore state\n            const state = decodeOAuthState(query.state);\n            data = await fetchToken(state.hassUrl, state.clientId, query.code);\n            if (options.saveTokens) {\n                options.saveTokens(data);\n            }\n        }\n    }\n    // Check for stored tokens\n    if (!data && options.loadTokens) {\n        data = await options.loadTokens();\n    }\n    if (data) {\n        return new Auth(data, options.saveTokens);\n    }\n    if (hassUrl === undefined) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ERR_HASS_HOST_REQUIRED;\n    }\n    // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n    redirectAuthorize(hassUrl, clientId, options.redirectUrl || genRedirectUrl(), encodeOAuthState({\n        hassUrl,\n        clientId,\n    }));\n    // Just don't resolve while we navigate to next page\n    return new Promise(() => { });\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/auth.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/collection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/collection.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createCollection\": () => (/* binding */ createCollection),\n/* harmony export */   \"getCollection\": () => (/* binding */ getCollection)\n/* harmony export */ });\n/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store.js */ \"./node_modules/home-assistant-js-websocket/dist/store.js\");\n\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nconst getCollection = (conn, key, fetchCollection, subscribeUpdates) => {\n    if (conn[key]) {\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = (0,_store_js__WEBPACK_IMPORTED_MODULE_0__.createStore)();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    scheduleTeardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nconst createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/collection.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/commands.js":
/*!*******************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/commands.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"callService\": () => (/* binding */ callService),\n/* harmony export */   \"getConfig\": () => (/* binding */ getConfig),\n/* harmony export */   \"getServices\": () => (/* binding */ getServices),\n/* harmony export */   \"getStates\": () => (/* binding */ getStates),\n/* harmony export */   \"getUser\": () => (/* binding */ getUser)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/home-assistant-js-websocket/dist/messages.js\");\n\nconst getStates = (connection) => connection.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.states());\nconst getServices = (connection) => connection.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.services());\nconst getConfig = (connection) => connection.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.config());\nconst getUser = (connection) => connection.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.user());\nconst callService = (connection, domain, service, serviceData, target) => connection.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.callService(domain, service, serviceData, target));\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/commands.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/config.js":
/*!*****************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/config.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"STATE_FINAL_WRITE\": () => (/* binding */ STATE_FINAL_WRITE),\n/* harmony export */   \"STATE_NOT_RUNNING\": () => (/* binding */ STATE_NOT_RUNNING),\n/* harmony export */   \"STATE_RUNNING\": () => (/* binding */ STATE_RUNNING),\n/* harmony export */   \"STATE_STARTING\": () => (/* binding */ STATE_STARTING),\n/* harmony export */   \"STATE_STOPPING\": () => (/* binding */ STATE_STOPPING),\n/* harmony export */   \"configColl\": () => (/* binding */ configColl),\n/* harmony export */   \"subscribeConfig\": () => (/* binding */ subscribeConfig)\n/* harmony export */ });\n/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection.js */ \"./node_modules/home-assistant-js-websocket/dist/collection.js\");\n/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands.js */ \"./node_modules/home-assistant-js-websocket/dist/commands.js\");\n\n\nfunction processComponentLoaded(state, event) {\n    if (state === undefined)\n        return null;\n    return {\n        components: state.components.concat(event.data.component),\n    };\n}\nconst fetchConfig = (conn) => (0,_commands_js__WEBPACK_IMPORTED_MODULE_0__.getConfig)(conn);\nconst subscribeUpdates = (conn, store) => Promise.all([\n    conn.subscribeEvents(store.action(processComponentLoaded), \"component_loaded\"),\n    conn.subscribeEvents(() => fetchConfig(conn).then((config) => store.setState(config, true)), \"core_config_updated\"),\n]).then((unsubs) => () => unsubs.forEach((unsub) => unsub()));\nconst configColl = (conn) => (0,_collection_js__WEBPACK_IMPORTED_MODULE_1__.getCollection)(conn, \"_cnf\", fetchConfig, subscribeUpdates);\nconst subscribeConfig = (conn, onChange) => configColl(conn).subscribe(onChange);\nconst STATE_NOT_RUNNING = \"NOT_RUNNING\";\nconst STATE_STARTING = \"STARTING\";\nconst STATE_RUNNING = \"RUNNING\";\nconst STATE_STOPPING = \"STOPPING\";\nconst STATE_FINAL_WRITE = \"FINAL_WRITE\";\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/config.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/connection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/connection.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Connection\": () => (/* binding */ Connection)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/home-assistant-js-websocket/dist/messages.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/home-assistant-js-websocket/dist/errors.js\");\n/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\n\n\nconst DEBUG = false;\nclass Connection {\n    constructor(socket, options) {\n        this._handleMessage = (event) => {\n            let messageGroup = JSON.parse(event.data);\n            if (!Array.isArray(messageGroup)) {\n                messageGroup = [messageGroup];\n            }\n            messageGroup.forEach((message) => {\n                if (DEBUG) {\n                    console.log(\"Received\", message);\n                }\n                const info = this.commands.get(message.id);\n                switch (message.type) {\n                    case \"event\":\n                        if (info) {\n                            info.callback(message.event);\n                        }\n                        else {\n                            console.warn(`Received event for unknown subscription ${message.id}. Unsubscribing.`);\n                            this.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.unsubscribeEvents(message.id));\n                        }\n                        break;\n                    case \"result\":\n                        // No info is fine. If just sendMessage is used, we did not store promise for result\n                        if (info) {\n                            if (message.success) {\n                                info.resolve(message.result);\n                                // Don't remove subscriptions.\n                                if (!(\"subscribe\" in info)) {\n                                    this.commands.delete(message.id);\n                                }\n                            }\n                            else {\n                                info.reject(message.error);\n                                this.commands.delete(message.id);\n                            }\n                        }\n                        break;\n                    case \"pong\":\n                        if (info) {\n                            info.resolve();\n                            this.commands.delete(message.id);\n                        }\n                        else {\n                            console.warn(`Received unknown pong response ${message.id}`);\n                        }\n                        break;\n                    default:\n                        if (DEBUG) {\n                            console.warn(\"Unhandled message\", message);\n                        }\n                }\n            });\n        };\n        this._handleClose = async () => {\n            const oldCommands = this.commands;\n            // reset to original state except haVersion\n            this.commandId = 1;\n            this.oldSubscriptions = this.commands;\n            this.commands = new Map();\n            this.socket = undefined;\n            // Reject in-flight sendMessagePromise requests\n            oldCommands.forEach((info) => {\n                // We don't cancel subscribeEvents commands in flight\n                // as we will be able to recover them.\n                if (!(\"subscribe\" in info)) {\n                    info.reject(_messages_js__WEBPACK_IMPORTED_MODULE_0__.error(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ERR_CONNECTION_LOST, \"Connection lost\"));\n                }\n            });\n            if (this.closeRequested) {\n                return;\n            }\n            this.fireEvent(\"disconnected\");\n            // Disable setupRetry, we control it here with auto-backoff\n            const options = Object.assign(Object.assign({}, this.options), { setupRetry: 0 });\n            const reconnect = (tries) => {\n                setTimeout(async () => {\n                    if (this.closeRequested) {\n                        return;\n                    }\n                    if (DEBUG) {\n                        console.log(\"Trying to reconnect\");\n                    }\n                    try {\n                        const socket = await options.createSocket(options);\n                        this._setSocket(socket);\n                    }\n                    catch (err) {\n                        if (this._queuedMessages) {\n                            const queuedMessages = this._queuedMessages;\n                            this._queuedMessages = undefined;\n                            for (const msg of queuedMessages) {\n                                if (msg.reject) {\n                                    msg.reject(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ERR_CONNECTION_LOST);\n                                }\n                            }\n                        }\n                        if (err === _errors_js__WEBPACK_IMPORTED_MODULE_1__.ERR_INVALID_AUTH) {\n                            this.fireEvent(\"reconnect-error\", err);\n                        }\n                        else {\n                            reconnect(tries + 1);\n                        }\n                    }\n                }, Math.min(tries, 5) * 1000);\n            };\n            if (this.suspendReconnectPromise) {\n                await this.suspendReconnectPromise;\n                this.suspendReconnectPromise = undefined;\n                // For the first retry after suspend, we will queue up\n                // all messages.\n                this._queuedMessages = [];\n            }\n            reconnect(0);\n        };\n        // connection options\n        //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n        //  - createSocket: create a new Socket connection\n        this.options = options;\n        // id if next command to send\n        this.commandId = 2; // socket may send 1 at the start to enable features\n        // info about active subscriptions and commands in flight\n        this.commands = new Map();\n        // map of event listeners\n        this.eventListeners = new Map();\n        // true if a close is requested by the user\n        this.closeRequested = false;\n        this._setSocket(socket);\n    }\n    get connected() {\n        // Using conn.socket.OPEN instead of WebSocket for better node support\n        return (this.socket !== undefined && this.socket.readyState == this.socket.OPEN);\n    }\n    _setSocket(socket) {\n        this.socket = socket;\n        this.haVersion = socket.haVersion;\n        socket.addEventListener(\"message\", this._handleMessage);\n        socket.addEventListener(\"close\", this._handleClose);\n        const oldSubscriptions = this.oldSubscriptions;\n        if (oldSubscriptions) {\n            this.oldSubscriptions = undefined;\n            oldSubscriptions.forEach((info) => {\n                if (\"subscribe\" in info && info.subscribe) {\n                    info.subscribe().then((unsub) => {\n                        info.unsubscribe = unsub;\n                        // We need to resolve this in case it wasn't resolved yet.\n                        // This allows us to subscribe while we're disconnected\n                        // and recover properly.\n                        info.resolve();\n                    });\n                }\n            });\n        }\n        const queuedMessages = this._queuedMessages;\n        if (queuedMessages) {\n            this._queuedMessages = undefined;\n            for (const queuedMsg of queuedMessages) {\n                queuedMsg.resolve();\n            }\n        }\n        this.fireEvent(\"ready\");\n    }\n    addEventListener(eventType, callback) {\n        let listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            listeners = [];\n            this.eventListeners.set(eventType, listeners);\n        }\n        listeners.push(callback);\n    }\n    removeEventListener(eventType, callback) {\n        const listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(callback);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    }\n    fireEvent(eventType, eventData) {\n        (this.eventListeners.get(eventType) || []).forEach((callback) => callback(this, eventData));\n    }\n    suspendReconnectUntil(suspendPromise) {\n        this.suspendReconnectPromise = suspendPromise;\n    }\n    suspend() {\n        if (!this.suspendReconnectPromise) {\n            throw new Error(\"Suspend promise not set\");\n        }\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Reconnect the websocket connection.\n     * @param force discard old socket instead of gracefully closing it.\n     */\n    reconnect(force = false) {\n        if (!this.socket) {\n            return;\n        }\n        if (!force) {\n            this.socket.close();\n            return;\n        }\n        this.socket.removeEventListener(\"message\", this._handleMessage);\n        this.socket.removeEventListener(\"close\", this._handleClose);\n        this.socket.close();\n        this._handleClose();\n    }\n    close() {\n        this.closeRequested = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Subscribe to a specific or all events.\n     *\n     * @param callback Callback  to be called when a new event fires\n     * @param eventType\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeEvents(callback, eventType) {\n        return this.subscribeMessage(callback, _messages_js__WEBPACK_IMPORTED_MODULE_0__.subscribeEvents(eventType));\n    }\n    ping() {\n        return this.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.ping());\n    }\n    sendMessage(message, commandId) {\n        if (!this.connected) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ERR_CONNECTION_LOST;\n        }\n        if (DEBUG) {\n            console.log(\"Sending\", message);\n        }\n        if (this._queuedMessages) {\n            if (commandId) {\n                throw new Error(\"Cannot queue with commandId\");\n            }\n            this._queuedMessages.push({ resolve: () => this.sendMessage(message) });\n            return;\n        }\n        if (!commandId) {\n            commandId = this._genCmdId();\n        }\n        message.id = commandId;\n        this.socket.send(JSON.stringify(message));\n    }\n    sendMessagePromise(message) {\n        return new Promise((resolve, reject) => {\n            if (this._queuedMessages) {\n                this._queuedMessages.push({\n                    reject,\n                    resolve: async () => {\n                        try {\n                            resolve(await this.sendMessagePromise(message));\n                        }\n                        catch (err) {\n                            reject(err);\n                        }\n                    },\n                });\n                return;\n            }\n            const commandId = this._genCmdId();\n            this.commands.set(commandId, { resolve, reject });\n            this.sendMessage(message, commandId);\n        });\n    }\n    /**\n     * Call a websocket command that starts a subscription on the backend.\n     *\n     * @param message the message to start the subscription\n     * @param callback the callback to be called when a new item arrives\n     * @param [options.resubscribe] re-established a subscription after a reconnect. Defaults to true.\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeMessage(callback, subscribeMessage, options) {\n        if (this._queuedMessages) {\n            await new Promise((resolve, reject) => {\n                this._queuedMessages.push({ resolve, reject });\n            });\n        }\n        let info;\n        await new Promise((resolve, reject) => {\n            // Command ID that will be used\n            const commandId = this._genCmdId();\n            // We store unsubscribe on info object. That way we can overwrite it in case\n            // we get disconnected and we have to subscribe again.\n            info = {\n                resolve,\n                reject,\n                callback,\n                subscribe: (options === null || options === void 0 ? void 0 : options.resubscribe) !== false\n                    ? () => this.subscribeMessage(callback, subscribeMessage)\n                    : undefined,\n                unsubscribe: async () => {\n                    // No need to unsubscribe if we're disconnected\n                    if (this.connected) {\n                        await this.sendMessagePromise(_messages_js__WEBPACK_IMPORTED_MODULE_0__.unsubscribeEvents(commandId));\n                    }\n                    this.commands.delete(commandId);\n                },\n            };\n            this.commands.set(commandId, info);\n            try {\n                this.sendMessage(subscribeMessage, commandId);\n            }\n            catch (err) {\n                // Happens when the websocket is already closing.\n                // Don't have to handle the error, reconnect logic will pick it up.\n            }\n        });\n        return () => info.unsubscribe();\n    }\n    _genCmdId() {\n        return ++this.commandId;\n    }\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/connection.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/entities.js":
/*!*******************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/entities.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"entitiesColl\": () => (/* binding */ entitiesColl),\n/* harmony export */   \"subscribeEntities\": () => (/* binding */ subscribeEntities)\n/* harmony export */ });\n/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collection.js */ \"./node_modules/home-assistant-js-websocket/dist/collection.js\");\n/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands.js */ \"./node_modules/home-assistant-js-websocket/dist/commands.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/home-assistant-js-websocket/dist/util.js\");\n\n\n\nfunction processEvent(store, updates) {\n    const state = Object.assign({}, store.state);\n    if (updates.a) {\n        for (const entityId in updates.a) {\n            const newState = updates.a[entityId];\n            let last_changed = new Date(newState.lc * 1000).toISOString();\n            state[entityId] = {\n                entity_id: entityId,\n                state: newState.s,\n                attributes: newState.a,\n                context: typeof newState.c === \"string\"\n                    ? { id: newState.c, parent_id: null, user_id: null }\n                    : newState.c,\n                last_changed: last_changed,\n                last_updated: newState.lu\n                    ? new Date(newState.lu * 1000).toISOString()\n                    : last_changed,\n            };\n        }\n    }\n    if (updates.r) {\n        for (const entityId of updates.r) {\n            delete state[entityId];\n        }\n    }\n    if (updates.c) {\n        for (const entityId in updates.c) {\n            let entityState = state[entityId];\n            if (!entityState) {\n                console.warn(\"Received state update for unknown entity\", entityId);\n                continue;\n            }\n            entityState = Object.assign({}, entityState);\n            const { \"+\": toAdd, \"-\": toRemove } = updates.c[entityId];\n            const attributesChanged = (toAdd === null || toAdd === void 0 ? void 0 : toAdd.a) || (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a);\n            const attributes = attributesChanged\n                ? Object.assign({}, entityState.attributes) : entityState.attributes;\n            if (toAdd) {\n                if (toAdd.s !== undefined) {\n                    entityState.state = toAdd.s;\n                }\n                if (toAdd.c) {\n                    if (typeof toAdd.c === \"string\") {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), { id: toAdd.c });\n                    }\n                    else {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), toAdd.c);\n                    }\n                }\n                if (toAdd.lc) {\n                    entityState.last_updated = entityState.last_changed = new Date(toAdd.lc * 1000).toISOString();\n                }\n                else if (toAdd.lu) {\n                    entityState.last_updated = new Date(toAdd.lu * 1000).toISOString();\n                }\n                if (toAdd.a) {\n                    Object.assign(attributes, toAdd.a);\n                }\n            }\n            if (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a) {\n                for (const key of toRemove.a) {\n                    delete attributes[key];\n                }\n            }\n            if (attributesChanged) {\n                entityState.attributes = attributes;\n            }\n            state[entityId] = entityState;\n        }\n    }\n    store.setState(state, true);\n}\nconst subscribeUpdates = (conn, store) => conn.subscribeMessage((ev) => processEvent(store, ev), {\n    type: \"subscribe_entities\",\n});\nfunction legacyProcessEvent(store, event) {\n    const state = store.state;\n    if (state === undefined)\n        return;\n    const { entity_id, new_state } = event.data;\n    if (new_state) {\n        store.setState({ [new_state.entity_id]: new_state });\n    }\n    else {\n        const newEntities = Object.assign({}, state);\n        delete newEntities[entity_id];\n        store.setState(newEntities, true);\n    }\n}\nasync function legacyFetchEntities(conn) {\n    const states = await (0,_commands_js__WEBPACK_IMPORTED_MODULE_0__.getStates)(conn);\n    const entities = {};\n    for (let i = 0; i < states.length; i++) {\n        const state = states[i];\n        entities[state.entity_id] = state;\n    }\n    return entities;\n}\nconst legacySubscribeUpdates = (conn, store) => conn.subscribeEvents((ev) => legacyProcessEvent(store, ev), \"state_changed\");\nconst entitiesColl = (conn) => (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.atLeastHaVersion)(conn.haVersion, 2022, 4, 0)\n    ? (0,_collection_js__WEBPACK_IMPORTED_MODULE_2__.getCollection)(conn, \"_ent\", undefined, subscribeUpdates)\n    : (0,_collection_js__WEBPACK_IMPORTED_MODULE_2__.getCollection)(conn, \"_ent\", legacyFetchEntities, legacySubscribeUpdates);\nconst subscribeEntities = (conn, onChange) => entitiesColl(conn).subscribe(onChange);\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/entities.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/errors.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ERR_CANNOT_CONNECT\": () => (/* binding */ ERR_CANNOT_CONNECT),\n/* harmony export */   \"ERR_CONNECTION_LOST\": () => (/* binding */ ERR_CONNECTION_LOST),\n/* harmony export */   \"ERR_HASS_HOST_REQUIRED\": () => (/* binding */ ERR_HASS_HOST_REQUIRED),\n/* harmony export */   \"ERR_INVALID_AUTH\": () => (/* binding */ ERR_INVALID_AUTH),\n/* harmony export */   \"ERR_INVALID_HTTPS_TO_HTTP\": () => (/* binding */ ERR_INVALID_HTTPS_TO_HTTP)\n/* harmony export */ });\nconst ERR_CANNOT_CONNECT = 1;\nconst ERR_INVALID_AUTH = 2;\nconst ERR_CONNECTION_LOST = 3;\nconst ERR_HASS_HOST_REQUIRED = 4;\nconst ERR_INVALID_HTTPS_TO_HTTP = 5;\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/errors.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Auth\": () => (/* reexport safe */ _auth_js__WEBPACK_IMPORTED_MODULE_0__.Auth),\n/* harmony export */   \"Connection\": () => (/* reexport safe */ _connection_js__WEBPACK_IMPORTED_MODULE_2__.Connection),\n/* harmony export */   \"ERR_CANNOT_CONNECT\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_6__.ERR_CANNOT_CONNECT),\n/* harmony export */   \"ERR_CONNECTION_LOST\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_6__.ERR_CONNECTION_LOST),\n/* harmony export */   \"ERR_HASS_HOST_REQUIRED\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_6__.ERR_HASS_HOST_REQUIRED),\n/* harmony export */   \"ERR_INVALID_AUTH\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_6__.ERR_INVALID_AUTH),\n/* harmony export */   \"ERR_INVALID_HTTPS_TO_HTTP\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_6__.ERR_INVALID_HTTPS_TO_HTTP),\n/* harmony export */   \"MSG_TYPE_AUTH_INVALID\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_7__.MSG_TYPE_AUTH_INVALID),\n/* harmony export */   \"MSG_TYPE_AUTH_OK\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_7__.MSG_TYPE_AUTH_OK),\n/* harmony export */   \"MSG_TYPE_AUTH_REQUIRED\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_7__.MSG_TYPE_AUTH_REQUIRED),\n/* harmony export */   \"STATE_FINAL_WRITE\": () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_3__.STATE_FINAL_WRITE),\n/* harmony export */   \"STATE_NOT_RUNNING\": () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_3__.STATE_NOT_RUNNING),\n/* harmony export */   \"STATE_RUNNING\": () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_3__.STATE_RUNNING),\n/* harmony export */   \"STATE_STARTING\": () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_3__.STATE_STARTING),\n/* harmony export */   \"STATE_STOPPING\": () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_3__.STATE_STOPPING),\n/* harmony export */   \"callService\": () => (/* reexport safe */ _commands_js__WEBPACK_IMPORTED_MODULE_8__.callService),\n/* harmony export */   \"configColl\": () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_3__.configColl),\n/* harmony export */   \"createCollection\": () => (/* reexport safe */ _collection_js__WEBPACK_IMPORTED_MODULE_1__.createCollection),\n/* harmony export */   \"createConnection\": () => (/* binding */ createConnection),\n/* harmony export */   \"createLongLivedTokenAuth\": () => (/* reexport safe */ _auth_js__WEBPACK_IMPORTED_MODULE_0__.createLongLivedTokenAuth),\n/* harmony export */   \"createSocket\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_7__.createSocket),\n/* harmony export */   \"entitiesColl\": () => (/* reexport safe */ _entities_js__WEBPACK_IMPORTED_MODULE_5__.entitiesColl),\n/* harmony export */   \"genClientId\": () => (/* reexport safe */ _auth_js__WEBPACK_IMPORTED_MODULE_0__.genClientId),\n/* harmony export */   \"genExpires\": () => (/* reexport safe */ _auth_js__WEBPACK_IMPORTED_MODULE_0__.genExpires),\n/* harmony export */   \"getAuth\": () => (/* reexport safe */ _auth_js__WEBPACK_IMPORTED_MODULE_0__.getAuth),\n/* harmony export */   \"getCollection\": () => (/* reexport safe */ _collection_js__WEBPACK_IMPORTED_MODULE_1__.getCollection),\n/* harmony export */   \"getConfig\": () => (/* reexport safe */ _commands_js__WEBPACK_IMPORTED_MODULE_8__.getConfig),\n/* harmony export */   \"getServices\": () => (/* reexport safe */ _commands_js__WEBPACK_IMPORTED_MODULE_8__.getServices),\n/* harmony export */   \"getStates\": () => (/* reexport safe */ _commands_js__WEBPACK_IMPORTED_MODULE_8__.getStates),\n/* harmony export */   \"getUser\": () => (/* reexport safe */ _commands_js__WEBPACK_IMPORTED_MODULE_8__.getUser),\n/* harmony export */   \"servicesColl\": () => (/* reexport safe */ _services_js__WEBPACK_IMPORTED_MODULE_4__.servicesColl),\n/* harmony export */   \"subscribeConfig\": () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_3__.subscribeConfig),\n/* harmony export */   \"subscribeEntities\": () => (/* reexport safe */ _entities_js__WEBPACK_IMPORTED_MODULE_5__.subscribeEntities),\n/* harmony export */   \"subscribeServices\": () => (/* reexport safe */ _services_js__WEBPACK_IMPORTED_MODULE_4__.subscribeServices)\n/* harmony export */ });\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./socket.js */ \"./node_modules/home-assistant-js-websocket/dist/socket.js\");\n/* harmony import */ var _connection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./connection.js */ \"./node_modules/home-assistant-js-websocket/dist/connection.js\");\n/* harmony import */ var _auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth.js */ \"./node_modules/home-assistant-js-websocket/dist/auth.js\");\n/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection.js */ \"./node_modules/home-assistant-js-websocket/dist/collection.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config.js */ \"./node_modules/home-assistant-js-websocket/dist/config.js\");\n/* harmony import */ var _services_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./services.js */ \"./node_modules/home-assistant-js-websocket/dist/services.js\");\n/* harmony import */ var _entities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entities.js */ \"./node_modules/home-assistant-js-websocket/dist/entities.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/home-assistant-js-websocket/dist/errors.js\");\n/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commands.js */ \"./node_modules/home-assistant-js-websocket/dist/commands.js\");\n// JS extensions in imports allow tsc output to be consumed by browsers.\n\n\n\n\n\n\n\n\n\n\n\n\nasync function createConnection(options) {\n    const connOptions = Object.assign({ setupRetry: 0, createSocket: _socket_js__WEBPACK_IMPORTED_MODULE_7__.createSocket }, options);\n    const socket = await connOptions.createSocket(connOptions);\n    const conn = new _connection_js__WEBPACK_IMPORTED_MODULE_2__.Connection(socket, connOptions);\n    return conn;\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/index.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/messages.js":
/*!*******************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/messages.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"auth\": () => (/* binding */ auth),\n/* harmony export */   \"callService\": () => (/* binding */ callService),\n/* harmony export */   \"config\": () => (/* binding */ config),\n/* harmony export */   \"error\": () => (/* binding */ error),\n/* harmony export */   \"ping\": () => (/* binding */ ping),\n/* harmony export */   \"services\": () => (/* binding */ services),\n/* harmony export */   \"states\": () => (/* binding */ states),\n/* harmony export */   \"subscribeEvents\": () => (/* binding */ subscribeEvents),\n/* harmony export */   \"supportedFeatures\": () => (/* binding */ supportedFeatures),\n/* harmony export */   \"unsubscribeEvents\": () => (/* binding */ unsubscribeEvents),\n/* harmony export */   \"user\": () => (/* binding */ user)\n/* harmony export */ });\nfunction auth(accessToken) {\n    return {\n        type: \"auth\",\n        access_token: accessToken,\n    };\n}\nfunction supportedFeatures() {\n    return {\n        type: \"supported_features\",\n        id: 1,\n        features: { coalesce_messages: 1 },\n    };\n}\nfunction states() {\n    return {\n        type: \"get_states\",\n    };\n}\nfunction config() {\n    return {\n        type: \"get_config\",\n    };\n}\nfunction services() {\n    return {\n        type: \"get_services\",\n    };\n}\nfunction user() {\n    return {\n        type: \"auth/current_user\",\n    };\n}\nfunction callService(domain, service, serviceData, target) {\n    const message = {\n        type: \"call_service\",\n        domain,\n        service,\n        target,\n    };\n    if (serviceData) {\n        message.service_data = serviceData;\n    }\n    return message;\n}\nfunction subscribeEvents(eventType) {\n    const message = {\n        type: \"subscribe_events\",\n    };\n    if (eventType) {\n        message.event_type = eventType;\n    }\n    return message;\n}\nfunction unsubscribeEvents(subscription) {\n    return {\n        type: \"unsubscribe_events\",\n        subscription,\n    };\n}\nfunction ping() {\n    return {\n        type: \"ping\",\n    };\n}\nfunction error(code, message) {\n    return {\n        type: \"result\",\n        success: false,\n        error: {\n            code,\n            message,\n        },\n    };\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/messages.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/services.js":
/*!*******************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/services.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"servicesColl\": () => (/* binding */ servicesColl),\n/* harmony export */   \"subscribeServices\": () => (/* binding */ subscribeServices)\n/* harmony export */ });\n/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collection.js */ \"./node_modules/home-assistant-js-websocket/dist/collection.js\");\n/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commands.js */ \"./node_modules/home-assistant-js-websocket/dist/commands.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/home-assistant-js-websocket/dist/util.js\");\n\n\n\nfunction processServiceRegistered(conn, store, event) {\n    var _a;\n    const state = store.state;\n    if (state === undefined)\n        return;\n    const { domain, service } = event.data;\n    if (!((_a = state.domain) === null || _a === void 0 ? void 0 : _a.service)) {\n        const domainInfo = Object.assign(Object.assign({}, state[domain]), { [service]: { description: \"\", fields: {} } });\n        store.setState({ [domain]: domainInfo });\n    }\n    debouncedFetchServices(conn, store);\n}\nfunction processServiceRemoved(state, event) {\n    if (state === undefined)\n        return null;\n    const { domain, service } = event.data;\n    const curDomainInfo = state[domain];\n    if (!curDomainInfo || !(service in curDomainInfo))\n        return null;\n    const domainInfo = {};\n    Object.keys(curDomainInfo).forEach((sKey) => {\n        if (sKey !== service)\n            domainInfo[sKey] = curDomainInfo[sKey];\n    });\n    return { [domain]: domainInfo };\n}\nconst debouncedFetchServices = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.debounce)((conn, store) => fetchServices(conn).then((services) => store.setState(services, true)), 5000);\nconst fetchServices = (conn) => (0,_commands_js__WEBPACK_IMPORTED_MODULE_1__.getServices)(conn);\nconst subscribeUpdates = (conn, store) => Promise.all([\n    conn.subscribeEvents((ev) => processServiceRegistered(conn, store, ev), \"service_registered\"),\n    conn.subscribeEvents(store.action(processServiceRemoved), \"service_removed\"),\n]).then((unsubs) => () => unsubs.forEach((fn) => fn()));\nconst servicesColl = (conn) => (0,_collection_js__WEBPACK_IMPORTED_MODULE_2__.getCollection)(conn, \"_srv\", fetchServices, subscribeUpdates);\nconst subscribeServices = (conn, onChange) => servicesColl(conn).subscribe(onChange);\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/services.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/socket.js":
/*!*****************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/socket.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MSG_TYPE_AUTH_INVALID\": () => (/* binding */ MSG_TYPE_AUTH_INVALID),\n/* harmony export */   \"MSG_TYPE_AUTH_OK\": () => (/* binding */ MSG_TYPE_AUTH_OK),\n/* harmony export */   \"MSG_TYPE_AUTH_REQUIRED\": () => (/* binding */ MSG_TYPE_AUTH_REQUIRED),\n/* harmony export */   \"createSocket\": () => (/* binding */ createSocket)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/home-assistant-js-websocket/dist/errors.js\");\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/home-assistant-js-websocket/dist/messages.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./node_modules/home-assistant-js-websocket/dist/util.js\");\n/**\n * Create a web socket connection with a Home Assistant instance.\n */\n\n\n\nconst DEBUG = false;\nconst MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nconst MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nconst MSG_TYPE_AUTH_OK = \"auth_ok\";\nfunction createSocket(options) {\n    if (!options.auth) {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_0__.ERR_HASS_HOST_REQUIRED;\n    }\n    const auth = options.auth;\n    // Start refreshing expired tokens even before the WS connection is open.\n    // We know that we will need auth anyway.\n    let authRefreshTask = auth.expired\n        ? auth.refreshAccessToken().then(() => {\n            authRefreshTask = undefined;\n        }, () => {\n            authRefreshTask = undefined;\n        })\n        : undefined;\n    // Convert from http:// -> ws://, https:// -> wss://\n    const url = auth.wsUrl;\n    if (DEBUG) {\n        console.log(\"[Auth phase] Initializing\", url);\n    }\n    function connect(triesLeft, promResolve, promReject) {\n        if (DEBUG) {\n            console.log(\"[Auth Phase] New connection\", url);\n        }\n        const socket = new WebSocket(url);\n        // If invalid auth, we will not try to reconnect.\n        let invalidAuth = false;\n        const closeMessage = () => {\n            // If we are in error handler make sure close handler doesn't also fire.\n            socket.removeEventListener(\"close\", closeMessage);\n            if (invalidAuth) {\n                promReject(_errors_js__WEBPACK_IMPORTED_MODULE_0__.ERR_INVALID_AUTH);\n                return;\n            }\n            // Reject if we no longer have to retry\n            if (triesLeft === 0) {\n                // We never were connected and will not retry\n                promReject(_errors_js__WEBPACK_IMPORTED_MODULE_0__.ERR_CANNOT_CONNECT);\n                return;\n            }\n            const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n            // Try again in a second\n            setTimeout(() => connect(newTries, promResolve, promReject), 1000);\n        };\n        // Auth is mandatory, so we can send the auth message right away.\n        const handleOpen = async (event) => {\n            try {\n                if (auth.expired) {\n                    await (authRefreshTask ? authRefreshTask : auth.refreshAccessToken());\n                }\n                socket.send(JSON.stringify(_messages_js__WEBPACK_IMPORTED_MODULE_1__.auth(auth.accessToken)));\n            }\n            catch (err) {\n                // Refresh token failed\n                invalidAuth = err === _errors_js__WEBPACK_IMPORTED_MODULE_0__.ERR_INVALID_AUTH;\n                socket.close();\n            }\n        };\n        const handleMessage = async (event) => {\n            const message = JSON.parse(event.data);\n            if (DEBUG) {\n                console.log(\"[Auth phase] Received\", message);\n            }\n            switch (message.type) {\n                case MSG_TYPE_AUTH_INVALID:\n                    invalidAuth = true;\n                    socket.close();\n                    break;\n                case MSG_TYPE_AUTH_OK:\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"message\", handleMessage);\n                    socket.removeEventListener(\"close\", closeMessage);\n                    socket.removeEventListener(\"error\", closeMessage);\n                    socket.haVersion = message.ha_version;\n                    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.atLeastHaVersion)(socket.haVersion, 2022, 9)) {\n                        socket.send(JSON.stringify(_messages_js__WEBPACK_IMPORTED_MODULE_1__.supportedFeatures()));\n                    }\n                    promResolve(socket);\n                    break;\n                default:\n                    if (DEBUG) {\n                        // We already send response to this message when socket opens\n                        if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n                            console.warn(\"[Auth phase] Unhandled message\", message);\n                        }\n                    }\n            }\n        };\n        socket.addEventListener(\"open\", handleOpen);\n        socket.addEventListener(\"message\", handleMessage);\n        socket.addEventListener(\"close\", closeMessage);\n        socket.addEventListener(\"error\", closeMessage);\n    }\n    return new Promise((resolve, reject) => connect(options.setupRetry, resolve, reject));\n}\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/socket.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/store.js":
/*!****************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/store.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createStore\": () => (/* binding */ createStore)\n/* harmony export */ });\nconst createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/store.js?");

/***/ }),

/***/ "./node_modules/home-assistant-js-websocket/dist/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/home-assistant-js-websocket/dist/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"atLeastHaVersion\": () => (/* binding */ atLeastHaVersion),\n/* harmony export */   \"debounce\": () => (/* binding */ debounce),\n/* harmony export */   \"parseQuery\": () => (/* binding */ parseQuery)\n/* harmony export */ });\nfunction parseQuery(queryString) {\n    const query = {};\n    const items = queryString.split(\"&\");\n    for (let i = 0; i < items.length; i++) {\n        const item = items[i].split(\"=\");\n        const key = decodeURIComponent(item[0]);\n        const value = item.length > 1 ? decodeURIComponent(item[1]) : undefined;\n        query[key] = value;\n    }\n    return query;\n}\n// From: https://davidwalsh.name/javascript-debounce-function\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// eslint-disable-next-line: ban-types\nconst debounce = (func, wait, immediate = false) => {\n    let timeout;\n    // @ts-ignore\n    return function (...args) {\n        // @ts-ignore\n        const context = this;\n        const later = () => {\n            timeout = undefined;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n};\nconst atLeastHaVersion = (version, major, minor, patch) => {\n    const [haMajor, haMinor, haPatch] = version.split(\".\", 3);\n    return (Number(haMajor) > major ||\n        (Number(haMajor) === major &&\n            (patch === undefined\n                ? Number(haMinor) >= minor\n                : Number(haMinor) > minor)) ||\n        (patch !== undefined &&\n            Number(haMajor) === major &&\n            Number(haMinor) === minor &&\n            Number(haPatch) >= patch));\n};\n\n\n//# sourceURL=webpack://duckyc.github.io/./node_modules/home-assistant-js-websocket/dist/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".main.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;