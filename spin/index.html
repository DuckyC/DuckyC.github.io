<!DOCTYPE html>
<html>
    <head>
        <style>
            .split {
                height: 100%;
                width: 50%;
                position: fixed;
                z-index: 1;
                top: 0;
                overflow: hidden;
                padding-top: 20px;
            }

            .left {
                left: 0;
            }

            .right {
                right: 0;
            }
            #orginalContainer > *,
            #cropped {
                position: absolute;
                top: 0;
                right: 0;
                width: 100%;
                /* height: 100%; */
            }

            #color {
                position: absolute;
                top: 10px;
                right: 10px;
                width: 100px;
                height: 100px;
                background: gray;
            }

            #start,
            #connect {
                cursor: pointer;
            }
            #connect {
                top: 30px;
                /* display: none; */
            }
        </style>
        <script src="https://unpkg.com/fast-average-color/dist/index.browser.min.js"></script>
    </head>
    <body>
        <div id="orginalContainer" class="split left">
            <canvas id="video"></canvas>
            <canvas id="overlay"></canvas>
            <button id="start">Capture</button>
            <button id="connect">Connect</button>
        </div>
        <div class="split right">
            <canvas id="cropped"></canvas>
            <div id="color"></div>
        </div>
    </body>

    <script type="module">
        import {
            getAuth,
            getUser,
            callService,
            createConnection,
            subscribeEntities,
            ERR_HASS_HOST_REQUIRED,
        } from "https://unpkg.com/home-assistant-js-websocket@3.2.5/dist/haws.es.js";
        var worker;
        const startElem = document.getElementById("start");
        const connect = document.getElementById("connect");

        const video = document.getElementById("video");
        const overlay = document.getElementById("overlay");

        const cropped = document.getElementById("cropped");
        const output = document.getElementById("color");
        const fac = new FastAverageColor();

        startElem.onclick = async () => {
            const capture = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    cursor: "never",
                },
                audio: false,
            });

            video.srcObject = capture;
            const ctx = video.getContext("2d");
            const track = capture.getVideoTracks()[0];
            const processor = new MediaStreamTrackProcessor(track);

            const canvasWriter = new WritableStream({
                write(value) {
                    if (video.width !== value.displayWidth || video.height !== value.displayHeight) {
                        video.width = value.displayWidth;
                        video.height = value.displayHeight;

                        const { width, height, left, top } = video.getBoundingClientRect();
                        overlay.width = video.width;
                        overlay.height = video.height;
                        console.log(video.width, overlay.width)
                        // overlay.style.width = width + "px";
                        // overlay.style.height = height + "px";
                        overlay.style.left = left + "px";
                        overlay.style.top = top + "px";
                    }

                    ctx.clearRect(0, 0, video.width, video.height);
                    ctx.drawImage(value, 0, 0);
                    value.close();
                },
            });

            processor.readable.pipeTo(canvasWriter);

            startElem.style.display = "none";
        };

        const cropVideo = (x, y, width, height) => {
            x = x * overlay.width;
            width = width * overlay.width;
            
            y = y * overlay.height;
            height = height * overlay.height;

            if (worker) {
                worker.terminate();
            }
            worker = new Worker("./worker.js", { name: "Crop worker" });
            const [track] = video.srcObject.getTracks();
            const processor = new MediaStreamTrackProcessor({ track });
            const { readable } = processor;

            const generator = new MediaStreamTrackGenerator({ kind: "video" });
            const { writable } = generator;

            //cropped.srcObject
            const mediaStream = new MediaStream([generator]);

            const processor2 = new MediaStreamTrackProcessor({
                track: mediaStream.getVideoTracks()[0],
            });
            const readable2 = processor2.readable;

            const ctx = cropped.getContext("2d");
            const canvasWriter = new WritableStream({
                write(value) {
                    if (cropped.width !== value.displayWidth || cropped.height !== value.displayHeight) {
                        cropped.width = value.displayWidth;
                        cropped.height = value.displayHeight;
                    }

                    ctx.clearRect(0, 0, video.width, video.height);
                    ctx.drawImage(value, 0, 0);
                    value.close();

                    const color = fac.getColor(cropped, {
                        algorithm: "dominant",
                        ignoredColor: [
                            [0, 0, 0, 255, 50],
                            [255, 255, 255, 255, 50],
                        ],
                    });

                    const hsv = RGBtoHSV(...color.value);
                    if (hsv.h == 0) {
                        output.colorvalue = [0, 0, 0];
                    } else {
                        const trueColor = HSVtoRGB(hsv.h, 1, 1);

                        output.colorvalue = [trueColor.r, trueColor.g, trueColor.b];
                    }

                    output.style["background-color"] = `rgb(${output.colorvalue.join(",")})`;
                },
            });

            readable2.pipeTo(canvasWriter);

            const canvasRect = overlay.getBoundingClientRect();
            const settings = track.getSettings();

            console.log(x, y, width, height);
            console.log({
                canvasWidth: canvasRect.width,
                canvasHeight: canvasRect.height,
                trackWidth: settings.width,
                trackHeight: settings.height,
            });

            worker.postMessage(
                {
                    x,
                    y,
                    width,
                    height,
                    readable,
                    writable,
                },
                [readable, writable]
            );
        };

        const drawRect = (x, y, w, h) => {
            const ctx = overlay.getContext("2d");

            
            x = x * overlay.width;
            w = w * overlay.width;
            
            y = y * overlay.height;
            h = h * overlay.height;

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            ctx.lineWidth = overlay.width / 300;
            ctx.strokeStyle = "red";
            ctx.strokeRect(x, y, w, h);
        };

        const ev = (c) => (e) => {
            e.preventDefault();
            e.stopPropagation();
            c(e);
        };

        var isDown = false;
        var startX;
        var startY;
        overlay.onmousedown = ev((e) => {
            if (!video.srcObject) {
                return;
            }
            isDown = true;

            const { width, height } = overlay.getBoundingClientRect();
            startX = e.offsetX / width;
            startY = e.offsetY / height;
        });

        overlay.onmousemove = ev((e) => {
            if (!isDown) return;

            const { width, height } = overlay.getBoundingClientRect();
            drawRect(startX, startY, (e.offsetX / width) - startX, (e.offsetY / height) - startY);
        });

        overlay.onmouseout = ev((e) => {
            isDown = false;
        });

        overlay.onmouseup = ev((e) => {
            if (!isDown) return;
            isDown = false;

            const { width, height } = overlay.getBoundingClientRect();
            drawRect(startX, startY, (e.offsetX / width) - startX, (e.offsetY / height) - startY);
            cropVideo(startX, startY, (e.offsetX / width) - startX, (e.offsetY / height) - startY);
        });

        let auth;
        const authOptions = {
            async loadTokens() {
                try {
                    return JSON.parse(localStorage.hassTokens);
                } catch (err) {
                    return undefined;
                }
            },
            saveTokens: (tokens) => {
                localStorage.hassTokens = JSON.stringify(tokens);
            },
        };

        connect.onclick = ev(async (e) => {
            try {
                auth = await getAuth(authOptions);
            } catch (err) {
                if (err === ERR_HASS_HOST_REQUIRED) {
                    authOptions.hassUrl = prompt("What host to connect to?", "http://192.168.0.10:8123");
                    if (!authOptions.hassUrl) return;
                    auth = await getAuth(authOptions);
                } else {
                    alert(`Unknown error: ${err}`);
                    return;
                }
            }

            const connection = await createConnection({ auth });
            for (const ev of ["disconnected", "ready", "reconnect-error"]) {
                connection.addEventListener(ev, () => console.log(`Event: ${ev}`));
            }

            // Clear url if we have been able to establish a connection
            if (location.search.includes("auth_callback=1")) {
                history.replaceState(null, "", location.pathname);
            }

            // To play from the console
            window.auth = auth;
            window.connection = connection;
            getUser(connection).then((user) => {
                console.log("Logged in as", user);
                window.user = user;
            });

            var lastColor;
            setInterval(async () => {
                if (
                    window.connection &&
                    output.colorvalue &&
                    (!lastColor ||
                        lastColor[0] !== output.colorvalue[0] ||
                        lastColor[1] !== output.colorvalue[1] ||
                        lastColor[2] !== output.colorvalue[2])
                ) {
                    lastColor = output.colorvalue;
                    await window.connection.sendMessagePromise({
                        type: "call_service",
                        domain: "light",
                        service: "turn_on",
                        service_data: {
                            rgb_color: output.colorvalue,
                            brightness: output.colorvalue[0] + output.colorvalue[1] + output.colorvalue[2] == 0 ? "0" : "255",
                            transition: false,
                        },
                        target: {
                            entity_id: "light.theball",
                        },
                    });
                }
            }, 100);
        });

        function RGBtoHSV(r, g, b) {
            if (arguments.length === 1) {
                (g = r.g), (b = r.b), (r = r.r);
            }
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                d = max - min,
                h,
                s = max === 0 ? 0 : d / max,
                v = max / 255;

            switch (max) {
                case min:
                    h = 0;
                    break;
                case r:
                    h = g - b + d * (g < b ? 6 : 0);
                    h /= 6 * d;
                    break;
                case g:
                    h = b - r + d * 2;
                    h /= 6 * d;
                    break;
                case b:
                    h = r - g + d * 4;
                    h /= 6 * d;
                    break;
            }

            return {
                h: h,
                s: s,
                v: v,
            };
        }

        function HSVtoRGB(h, s, v) {
            var r, g, b, i, f, p, q, t;
            if (arguments.length === 1) {
                (s = h.s), (v = h.v), (h = h.h);
            }
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0:
                    (r = v), (g = t), (b = p);
                    break;
                case 1:
                    (r = q), (g = v), (b = p);
                    break;
                case 2:
                    (r = p), (g = v), (b = t);
                    break;
                case 3:
                    (r = p), (g = q), (b = v);
                    break;
                case 4:
                    (r = t), (g = p), (b = v);
                    break;
                case 5:
                    (r = v), (g = p), (b = q);
                    break;
            }
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255),
            };
        }
    </script>
</html>
